package jpiccoli.io.ssl;

import java.io.IOException;
import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousByteChannel;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.CompletionHandler;
import java.util.Queue;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;

/**
 * An implementation of an AsynchronousByteChannel which uses the secure protocols provided
 * by a SSLEngine for encrypting and decrypting data transferred over the communication channel.
 * This class does not provide the functionalities of a {@code NetworkChannel}. Instead, it runs over another
 * existing AsynchronousByteChannel to which it delegates its {@code read} and {@code write} calls.
 * 
 * @author Juliano Piccoli
 *
 */
public class AsynchronousSSLChannel implements AsynchronousByteChannel {

    private static final boolean ASYNC_DISPATCH = false;

    private final AsynchronousByteChannel channel;
    private final SSLEngine engine;
    private final Executor executor;

    private final ByteBuffer inputBuffer;
    private final ByteBuffer outputBuffer;
    private final ByteBuffer emptyBuffer;

    private final ConsumingQueue<IOOperation<?>> pendingReadOperations;
    private final ConsumingQueue<IOOperation<?>> pendingWriteOperations;

    private final CompletionHandler<Integer, IOOperation<?>> readHandler;
    private final CompletionHandler<Integer, IOOperation<?>> writeHandler;

    /**
     * Constructor.
     * @param channel The delegate AsynchronousByteChannel.
     * @param engine The SSLEngine which provides the @{code wrap} and @{code unwrap} primitives.
     * @param executor Executor for running the delegates tasks generated by the SSLEngine during handshake.
     */
    public AsynchronousSSLChannel(final AsynchronousByteChannel channel, final SSLEngine engine, final Executor executor) {
        this.channel = channel;
        this.engine = engine;
        this.executor = executor;
        // TODO: These hard coded sizes for the input and output buffers seems... ugly.
        // We should probably allow the caller to specify these sizes.
        inputBuffer = ByteBuffer.allocateDirect(1024 * 1024).limit(0);
        outputBuffer = ByteBuffer.allocateDirect(1024 * 1024);
        emptyBuffer = ByteBuffer.allocate(0);
        pendingReadOperations = new ConsumingQueue<>();
        pendingWriteOperations = new ConsumingQueue<>();
        readHandler = IOHandlerBuilder.buildCompletionHandler(this::readCompleted, this::ioFailed);
        writeHandler = IOHandlerBuilder.buildCompletionHandler(this::writeCompleted, this::ioFailed);
    }

    @Override
    public <A> void read(final ByteBuffer buffer, final A attachment, final CompletionHandler<Integer, ? super A> completionHandler) {
        if (isOpen()) {
            pendingReadOperations.add(new IOOperation<>(buffer, attachment, completionHandler));
            nextRead();
        } else {
            dispatch(() -> completionHandler.completed(-1, attachment));
        }
    }

    @Override
    public Future<Integer> read(ByteBuffer dst) {
        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();
        read(dst, null, new CompletableFutureWrapper<>(completableFuture));
        return completableFuture;
    }

    @Override
    public <A> void write(final ByteBuffer buffer, final A attachment, final CompletionHandler<Integer, ? super A> completionHandler) {
        if (isOpen()) {
            pendingWriteOperations.add(new IOOperation<>(buffer, attachment, completionHandler));
            nextWrite();
        } else {
            dispatch(() -> completionHandler.failed(new ClosedChannelException(), attachment));
        }
    }

    @Override
    public Future<Integer> write(ByteBuffer src) {
        CompletableFuture<Integer> completableFuture = new CompletableFuture<>();
        write(src, null, new CompletableFutureWrapper<>(completableFuture));
        return completableFuture;
    }

    @Override
    public boolean isOpen() {
        return !engine.isInboundDone() && !engine.isOutboundDone() && channel.isOpen();
    }

    @Override
    public void close() throws IOException {
        channel.close();
        propagateClosingEvent();
    }

    private void dispatch(final Runnable async) {
    	// It is probably a good idea to dispatch these runnables on a different thread.
    	// On the other hand, using the provided Executor to run them might not be the way to go.
        if (ASYNC_DISPATCH) {
            executor.execute(async);
        } else {
            async.run();
        }
    }

    private void nextRead() {
        dispatch(() -> {
            IOOperation<?> readOperation = pendingReadOperations.consume();
            if (readOperation != null) {
                unwrap(readOperation);
            }
        });
    }

    private void nextWrite() {
        dispatch(() -> {
            IOOperation<?> writeOperation = pendingWriteOperations.consume();
            if (writeOperation != null) {
                wrap(writeOperation);
            }
        });
    }

    private void runEngine() {
        if (handleHandshake()) {
            nextRead();
            nextWrite();
        }
    }

    private boolean handleHandshake() {
        return handleHandshake(engine.getHandshakeStatus());
    }

    /**
     * Evaluate and act according to the handshake status.
     * @param handshakeStatus The handshake status to evaluate.
     * @return True if the calling thread can perform IO operations using the {@code nextRead}
     * or {@code nextWrite} after returning from this method. False otherwise.
     */
    private boolean handleHandshake(final SSLEngineResult.HandshakeStatus handshakeStatus) {
        switch (handshakeStatus) {
            case NEED_UNWRAP:
                read(emptyBuffer);
                return false;
            case NEED_WRAP:
                write(emptyBuffer);
                return false;
            case NEED_TASK:
                Runnable delegatedTask = engine.getDelegatedTask();
                if (delegatedTask != null) {
                    executor.execute(RunnableComposer.compose(delegatedTask, this::runEngine));
                }
                return false;
            case FINISHED:
                nextRead();
                nextWrite();
                return false;
            default:
                return true;
        }
    }

    private void propagateException(final Exception exception) {
        dispatch(() -> {
            Queue<IOOperation<?>> currentlyPendingReadOperations = pendingReadOperations.copyAndClear();
            for (IOOperation<?> readOperation : currentlyPendingReadOperations) {
                readOperation.fireException(exception);
            }
            Queue<IOOperation<?>> currentlyPendingWriteIoOperations = pendingWriteOperations.copyAndClear();
            for (IOOperation<?> writeOperation : currentlyPendingWriteIoOperations) {
                writeOperation.fireException(exception);
            }
        });
    }

    private void propagateClosingEvent() {
        dispatch(() -> {
            Queue<IOOperation<?>> currentlyPendingReadOperations = pendingReadOperations.copyAndClear();
            for (IOOperation<?> readOperation : currentlyPendingReadOperations) {
                readOperation.setByteCount(-1);
                readOperation.fireCompletion();
            }
            Queue<IOOperation<?>> currentlyPendingWriteIoOperations = pendingWriteOperations.copyAndClear();
            for (IOOperation<?> writeOperation : currentlyPendingWriteIoOperations) {
                writeOperation.fireException(new ClosedChannelException());
            }
        });
    }

    private void fireClosingEvent(final IOOperation<?> readOperation) {
        readOperation.setByteCount(-1);
        readOperation.fireCompletion();
        propagateClosingEvent();
    }

    private void unwrap(final IOOperation<?> ioOperation) {
        try {
            SSLEngineResult result = engine.unwrap(inputBuffer, ioOperation.getBuffer());
            // The JavaDocs for SSLEngine.unwrap method states that it decodes a single SSL/TLS packet in each call.
            // To maximize the efficiency and reduce the number of calls to the delegated channel's read method,
            // we decode as much packets as possible here.
            while (result.getStatus() == SSLEngineResult.Status.OK && result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
                ioOperation.incrementByteCount(result.bytesProduced());
                result = engine.unwrap(inputBuffer, ioOperation.getBuffer());
            }
            ioOperation.setLastEngineResult(result);
            if (ioOperation.getByteCount() == 0 && result.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {
                inputBuffer.compact();
                channel.read(inputBuffer, ioOperation, readHandler);
            } else {
                handleUnwrapResult(ioOperation);
            }
        } catch (SSLException e) {
            handleUnwrapException(e, ioOperation);
        }
    }

    private void handleUnwrapResult(final IOOperation<?> ioOperation) {
        if (ioOperation.getBuffer() == emptyBuffer) {
            pendingReadOperations.consumed(ioOperation);
        } else if (ioOperation.getByteCount() > 0) {
            ioOperation.fireCompletion();
            pendingReadOperations.consumed(ioOperation);
        } else {
            SSLEngineResult.Status status = ioOperation.getLastEngineResult().getStatus();
            if (status == SSLEngineResult.Status.BUFFER_OVERFLOW) {
                ioOperation.fireException(new BufferOverflowException());
                pendingReadOperations.consumed(ioOperation);
            } else if (status == SSLEngineResult.Status.CLOSED) {
                fireClosingEvent(ioOperation);
                pendingReadOperations.consumed(ioOperation);
            } else {
                pendingReadOperations.replay(ioOperation);
            }
        }
        if (handleHandshake(ioOperation.getLastEngineResult().getHandshakeStatus())) {
            nextRead();
        }
    }

    private void handleUnwrapException(final SSLException e, final IOOperation<?> ioOperation) {
        ioOperation.fireException(e);
        pendingReadOperations.consumed(ioOperation);
        if (ioOperation.getLastEngineResult().getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            propagateException(e);
        }
        if (handleHandshake()) {
            nextRead();
        }
    }

    private void wrap(final IOOperation<?> ioOperation) {
        try {
            outputBuffer.clear();
            // Despite the JavaDocs for SSLEngine.wrap stating that this method consumes as much bytes as possible from the source buffer,
            // it seems that, in practice, this is not true. For the same reason as in the unwrap method above, we call the unwrap method
            // many times to consume as much data as possible from the source buffer.
            SSLEngineResult result = engine.wrap(ioOperation.getBuffer(), outputBuffer);
            while (result.getStatus() == SSLEngineResult.Status.OK && result.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING
                && result.bytesConsumed() > 0) {
                ioOperation.incrementByteCount(result.bytesConsumed());
                result = engine.wrap(ioOperation.getBuffer(), outputBuffer);
            }
            ioOperation.setLastEngineResult(result);
            outputBuffer.flip();
            if (outputBuffer.hasRemaining()) {
                channel.write(outputBuffer, ioOperation, writeHandler);
            } else {
                handleWrapResult(ioOperation);
            }
        } catch (SSLException e) {
            handleWrapException(e, ioOperation);
        }
    }

    private void handleWrapResult(final IOOperation<?> ioOperation) {
        if (ioOperation.getBuffer() == emptyBuffer) {
            pendingWriteOperations.consumed(ioOperation);
        } else if (ioOperation.getByteCount() > 0) {
            ioOperation.fireCompletion();
            pendingWriteOperations.consumed(ioOperation);
        } else if (ioOperation.getLastEngineResult().getStatus() == SSLEngineResult.Status.CLOSED) {
            ioOperation.fireException(new ClosedChannelException());
        } else {
            pendingWriteOperations.replay(ioOperation);
        }
        if (handleHandshake(ioOperation.getLastEngineResult().getHandshakeStatus())) {
            nextWrite();
        }
    }

    private void handleWrapException(final SSLException e, final IOOperation<?> ioOperation) {
        ioOperation.fireException(e);
        pendingWriteOperations.consumed(ioOperation);
        if (ioOperation.getLastEngineResult().getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            propagateException(e);
        }
        if (handleHandshake()) {
            nextWrite();
        }
    }

    private void readCompleted(Integer result, IOOperation<?> attachment) {
        if (result != null && result < 0) {
            fireClosingEvent(attachment);
            pendingReadOperations.consumed(attachment);
            nextRead();
        } else {
            inputBuffer.flip();
            unwrap(attachment);
        }
    }

    private void writeCompleted(Integer result, IOOperation<?> attachment) {
        if (outputBuffer.hasRemaining()) {
            channel.write(outputBuffer, attachment, writeHandler);
        } else {
            handleWrapResult(attachment);
        }
    }

    private void ioFailed(Throwable exc, IOOperation<?> attachment) {
        attachment.fireException(exc);
    }

}
